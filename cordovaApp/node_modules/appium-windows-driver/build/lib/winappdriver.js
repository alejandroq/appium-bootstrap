'use strict';

var _get = require('babel-runtime/helpers/get')['default'];

var _inherits = require('babel-runtime/helpers/inherits')['default'];

var _createClass = require('babel-runtime/helpers/create-class')['default'];

var _classCallCheck = require('babel-runtime/helpers/class-call-check')['default'];

var _getIterator = require('babel-runtime/core-js/get-iterator')['default'];

var _regeneratorRuntime = require('babel-runtime/regenerator')['default'];

var _interopRequireDefault = require('babel-runtime/helpers/interop-require-default')['default'];

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _events = require('events');

var _events2 = _interopRequireDefault(_events);

var _appiumBaseDriver = require('appium-base-driver');

var _logger = require('./logger');

var _logger2 = _interopRequireDefault(_logger);

var _teen_process = require('teen_process');

var _installer = require('./installer');

//import { retryInterval } from 'asyncbox';

var _child_process = require('child_process');

var _child_process2 = _interopRequireDefault(_child_process);

var _bluebird = require('bluebird');

var _bluebird2 = _interopRequireDefault(_bluebird);

var REQD_PARAMS = ['app'];
var DEFAULT_HOST = '127.0.0.1';
var DEFAULT_PORT = "4823"; //  should be non-4723 to avoid conflict on the same box

var WinAppDriver = (function (_events$EventEmitter) {
  _inherits(WinAppDriver, _events$EventEmitter);

  function WinAppDriver() {
    var opts = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

    _classCallCheck(this, WinAppDriver);

    var host = opts.host;
    var port = opts.port;

    _get(Object.getPrototypeOf(WinAppDriver.prototype), 'constructor', this).call(this);

    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
      for (var _iterator = _getIterator(REQD_PARAMS), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var req = _step.value;

        if (!opts || !opts[req]) {
          throw new Error('Option \'' + req + '\' is required!');
        }
        this[req] = opts[req];
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator['return']) {
          _iterator['return']();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }

    this.proxyHost = host || DEFAULT_HOST;
    this.proxyPort = port || DEFAULT_PORT;
    this.proc = null;
    this.state = WinAppDriver.STATE_STOPPED;
    this.jwproxy = new _appiumBaseDriver.JWProxy({ server: this.proxyHost, port: this.proxyPort });
  }

  _createClass(WinAppDriver, [{
    key: 'start',
    value: function start() {
      var args, startDetector, processIsAlive, _arr, _loop, _i;

      return _regeneratorRuntime.async(function start$(context$2$0) {
        var _this = this;

        while (1) switch (context$2$0.prev = context$2$0.next) {
          case 0:
            context$2$0.next = 2;
            return _regeneratorRuntime.awrap((0, _installer.verifyWAD)());

          case 2:
            if (context$2$0.sent) {
              context$2$0.next = 4;
              break;
            }

            throw new Error("Could not verify WinAppDriver install; re-run install");

          case 4:

            this.changeState(WinAppDriver.STATE_STARTING);

            // XXXYD TODO: would be better if WinAppDriver didn't require passing in /wd/hub as a param
            args = [this.proxyPort + "/wd/hub"];

            startDetector = function startDetector(stdout) {
              return stdout.indexOf("listening for requests") !== -1;
            };

            processIsAlive = false;
            context$2$0.prev = 8;
            context$2$0.next = 11;
            return _regeneratorRuntime.awrap(this.killAll());

          case 11:

            // set up our subprocess object
            this.proc = new _teen_process.SubProcess(_installer.WAD_INSTALL_PATH, args, {
              encoding: 'ucs2'
            });
            processIsAlive = true;

            // handle log output
            _arr = ['STDOUT', 'STDERR'];

            _loop = function () {
              var stream = _arr[_i];
              _this.proc.on('lines-' + stream.toLowerCase(), function (lines) {
                var _iteratorNormalCompletion2 = true;
                var _didIteratorError2 = false;
                var _iteratorError2 = undefined;

                try {
                  for (var _iterator2 = _getIterator(lines), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
                    var l = _step2.value;

                    _logger2['default'].info('[' + stream + '] ' + l.trim());
                  }
                } catch (err) {
                  _didIteratorError2 = true;
                  _iteratorError2 = err;
                } finally {
                  try {
                    if (!_iteratorNormalCompletion2 && _iterator2['return']) {
                      _iterator2['return']();
                    }
                  } finally {
                    if (_didIteratorError2) {
                      throw _iteratorError2;
                    }
                  }
                }
              });
            };

            for (_i = 0; _i < _arr.length; _i++) {
              _loop();
            }

            // handle out-of-bound exit by simply emitting a stopped state
            this.proc.on('exit', function (code, signal) {
              processIsAlive = false;
              if (_this.state !== WinAppDriver.STATE_STOPPED && _this.state !== WinAppDriver.STATE_STOPPING) {
                var msg = 'WinAppDriver exited unexpectedly with code ' + code + ', ' + ('signal ' + signal);
                _logger2['default'].error(msg);
                _this.changeState(WinAppDriver.STATE_STOPPED);
              }
            });
            _logger2['default'].info('Spawning winappdriver with: ' + this.winappdriver + ' ' + ('' + args.join(' ')));

            // start subproc and wait for startDetector
            context$2$0.next = 20;
            return _regeneratorRuntime.awrap(this.proc.start(startDetector));

          case 20:
            context$2$0.next = 22;
            return _regeneratorRuntime.awrap(this.waitForOnline());

          case 22:
            this.changeState(WinAppDriver.STATE_ONLINE);
            context$2$0.next = 32;
            break;

          case 25:
            context$2$0.prev = 25;
            context$2$0.t0 = context$2$0['catch'](8);

            this.emit(WinAppDriver.EVENT_ERROR, context$2$0.t0);
            // just because we had an error doesn't mean the winappdriver process
            // finished; we should clean up if necessary

            if (!processIsAlive) {
              context$2$0.next = 31;
              break;
            }

            context$2$0.next = 31;
            return _regeneratorRuntime.awrap(this.proc.stop());

          case 31:
            _logger2['default'].errorAndThrow(context$2$0.t0);

          case 32:
          case 'end':
            return context$2$0.stop();
        }
      }, null, this, [[8, 25]]);
    }
  }, {
    key: 'sessionId',
    value: function sessionId() {
      if (this.state !== WinAppDriver.STATE_ONLINE) {
        return null;
      }

      return this.jwproxy.sessionId;
    }
  }, {
    key: 'waitForOnline',
    value: function waitForOnline() {
      return _regeneratorRuntime.async(function waitForOnline$(context$2$0) {
        while (1) switch (context$2$0.prev = context$2$0.next) {
          case 0:
            return context$2$0.abrupt('return', true);

          case 1:
          case 'end':
            return context$2$0.stop();
        }
      }, null, this);
    }
  }, {
    key: 'getStatus',

    // we need to make sure WAD hasn't crashed
    /*
    let winappdriverStopped = false;
    await retryInterval(20, 200, async () => {
      if (this.state === WinAppDriver.STATE_STOPPED) {
        // we are either stopped or stopping, so something went wrong
        winappdriverStopped = true;
        return;
      }
      await this.getStatus();
    });
    if (winappdriverStopped) {
      throw new Error('WinAppDriver crashed during startup.');
    }*/
    value: function getStatus() {
      return _regeneratorRuntime.async(function getStatus$(context$2$0) {
        while (1) switch (context$2$0.prev = context$2$0.next) {
          case 0:
            context$2$0.next = 2;
            return _regeneratorRuntime.awrap(this.jwproxy.command('/status', 'GET'));

          case 2:
            return context$2$0.abrupt('return', context$2$0.sent);

          case 3:
          case 'end':
            return context$2$0.stop();
        }
      }, null, this);
    }
  }, {
    key: 'startSession',
    value: function startSession(caps) {
      return _regeneratorRuntime.async(function startSession$(context$2$0) {
        while (1) switch (context$2$0.prev = context$2$0.next) {
          case 0:
            this.proxyReqRes = this.jwproxy.proxyReqRes.bind(this.jwproxy);
            context$2$0.next = 3;
            return _regeneratorRuntime.awrap(this.jwproxy.command('/session', 'POST', { desiredCapabilities: caps }));

          case 3:
          case 'end':
            return context$2$0.stop();
        }
      }, null, this);
    }
  }, {
    key: 'stop',
    value: function stop() {
      var emitStates = arguments.length <= 0 || arguments[0] === undefined ? true : arguments[0];
      return _regeneratorRuntime.async(function stop$(context$2$0) {
        while (1) switch (context$2$0.prev = context$2$0.next) {
          case 0:
            if (emitStates) {
              this.changeState(WinAppDriver.STATE_STOPPING);
            }
            context$2$0.prev = 1;

            if (!this.proc) {
              context$2$0.next = 5;
              break;
            }

            context$2$0.next = 5;
            return _regeneratorRuntime.awrap(this.proc.stop());

          case 5:
            if (emitStates) {
              this.changeState(WinAppDriver.STATE_STOPPED);
            }
            context$2$0.next = 11;
            break;

          case 8:
            context$2$0.prev = 8;
            context$2$0.t0 = context$2$0['catch'](1);

            _logger2['default'].error(context$2$0.t0);

          case 11:
          case 'end':
            return context$2$0.stop();
        }
      }, null, this, [[1, 8]]);
    }
  }, {
    key: 'changeState',
    value: function changeState(state) {
      this.state = state;
      _logger2['default'].debug('WinAppDriver changed state to \'' + state + '\'');
      this.emit(WinAppDriver.EVENT_CHANGED, { state: state });
    }
  }, {
    key: 'sendCommand',
    value: function sendCommand(url, method, body) {
      return _regeneratorRuntime.async(function sendCommand$(context$2$0) {
        while (1) switch (context$2$0.prev = context$2$0.next) {
          case 0:
            context$2$0.next = 2;
            return _regeneratorRuntime.awrap(this.jwproxy.command(url, method, body));

          case 2:
            return context$2$0.abrupt('return', context$2$0.sent);

          case 3:
          case 'end':
            return context$2$0.stop();
        }
      }, null, this);
    }
  }, {
    key: 'proxyReq',
    value: function proxyReq(req, res) {
      return _regeneratorRuntime.async(function proxyReq$(context$2$0) {
        while (1) switch (context$2$0.prev = context$2$0.next) {
          case 0:
            context$2$0.next = 2;
            return _regeneratorRuntime.awrap(this.jwproxy.proxyReqRes(req, res));

          case 2:
            return context$2$0.abrupt('return', context$2$0.sent);

          case 3:
          case 'end':
            return context$2$0.stop();
        }
      }, null, this);
    }
  }, {
    key: 'killAll',
    value: function killAll() {
      var cmd;
      return _regeneratorRuntime.async(function killAll$(context$2$0) {
        while (1) switch (context$2$0.prev = context$2$0.next) {
          case 0:
            cmd = undefined;

            // js hint cannot handle backticks, even escaped, within template literals
            cmd = "FOR /F \"usebackq tokens=5\" %a in (`netstat -nao ^| " + "findstr /R /C:\"" + this.proxyPort + " \"`) do (" + "FOR /F \"usebackq\" %b in (`TASKLIST /FI \"PID eq %a\" ^| " + "findstr /I winappdriver.exe`) do (IF NOT %b==\"\" TASKKILL " + "/F /PID %a))";
            _logger2['default'].info('Killing any old WinAppDrivers, running: ' + cmd);
            context$2$0.prev = 3;
            context$2$0.next = 6;
            return _regeneratorRuntime.awrap(_bluebird2['default'].promisify(_child_process2['default'].exec)(cmd));

          case 6:
            _logger2['default'].info("Successfully cleaned up old WinAppDrivers");
            context$2$0.next = 12;
            break;

          case 9:
            context$2$0.prev = 9;
            context$2$0.t0 = context$2$0['catch'](3);

            _logger2['default'].info("No old WinAppDrivers seemed to exist");

          case 12:
          case 'end':
            return context$2$0.stop();
        }
      }, null, this, [[3, 9]]);
    }
  }, {
    key: 'deleteSession',
    value: function deleteSession() {
      return _regeneratorRuntime.async(function deleteSession$(context$2$0) {
        while (1) switch (context$2$0.prev = context$2$0.next) {
          case 0:
            _logger2['default'].debug('Deleting WinAppDriver server session');
            // rely on jwproxy's intelligence to know what we're talking about and
            // delete the current session
            context$2$0.prev = 1;
            context$2$0.next = 4;
            return _regeneratorRuntime.awrap(this.jwproxy.command('/', 'DELETE'));

          case 4:
            context$2$0.next = 9;
            break;

          case 6:
            context$2$0.prev = 6;
            context$2$0.t0 = context$2$0['catch'](1);

            _logger2['default'].warn('Did not get confirmation WinAppDriver deleteSession worked; ' + ('Error was: ' + context$2$0.t0));

          case 9:
          case 'end':
            return context$2$0.stop();
        }
      }, null, this, [[1, 6]]);
    }
  }]);

  return WinAppDriver;
})(_events2['default'].EventEmitter);

WinAppDriver.EVENT_ERROR = 'winappdriver_error';
WinAppDriver.EVENT_CHANGED = 'stateChanged';
WinAppDriver.STATE_STOPPED = 'stopped';
WinAppDriver.STATE_STARTING = 'starting';
WinAppDriver.STATE_ONLINE = 'online';
WinAppDriver.STATE_STOPPING = 'stopping';

exports['default'] = WinAppDriver;
module.exports = exports['default'];

// XXXYD TODO: bring this back once WinAppDriver supports status correctly

// TODO WAD doesn't support the status command correctly, so just return
// true for now

// use cp.exec instead of teen process because of crazy windows quoting
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImxpYlxcd2luYXBwZHJpdmVyLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O3NCQUFtQixRQUFROzs7O2dDQUNILG9CQUFvQjs7c0JBQzVCLFVBQVU7Ozs7NEJBQ0MsY0FBYzs7eUJBQ0csYUFBYTs7Ozs2QkFFMUMsZUFBZTs7Ozt3QkFDaEIsVUFBVTs7OztBQUV4QixJQUFNLFdBQVcsR0FBRyxDQUFDLEtBQUssQ0FBQyxDQUFDO0FBQzVCLElBQU0sWUFBWSxHQUFHLFdBQVcsQ0FBQztBQUNqQyxJQUFNLFlBQVksR0FBRyxNQUFNLENBQUM7O0lBRXRCLFlBQVk7WUFBWixZQUFZOztBQUNKLFdBRFIsWUFBWSxHQUNRO1FBQVgsSUFBSSx5REFBRyxFQUFFOzswQkFEbEIsWUFBWTs7UUFFUCxJQUFJLEdBQVUsSUFBSSxDQUFsQixJQUFJO1FBQUUsSUFBSSxHQUFJLElBQUksQ0FBWixJQUFJOztBQUNqQiwrQkFIRSxZQUFZLDZDQUdOOzs7Ozs7O0FBRVIsd0NBQWdCLFdBQVcsNEdBQUU7WUFBcEIsR0FBRzs7QUFDVixZQUFJLENBQUMsSUFBSSxJQUFJLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFO0FBQ3ZCLGdCQUFNLElBQUksS0FBSyxlQUFZLEdBQUcscUJBQWlCLENBQUM7U0FDakQ7QUFDRCxZQUFJLENBQUMsR0FBRyxDQUFDLEdBQUcsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDO09BQ3ZCOzs7Ozs7Ozs7Ozs7Ozs7O0FBRUQsUUFBSSxDQUFDLFNBQVMsR0FBRyxJQUFJLElBQUksWUFBWSxDQUFDO0FBQ3RDLFFBQUksQ0FBQyxTQUFTLEdBQUcsSUFBSSxJQUFJLFlBQVksQ0FBQztBQUN0QyxRQUFJLENBQUMsSUFBSSxHQUFHLElBQUksQ0FBQztBQUNqQixRQUFJLENBQUMsS0FBSyxHQUFHLFlBQVksQ0FBQyxhQUFhLENBQUM7QUFDeEMsUUFBSSxDQUFDLE9BQU8sR0FBRyw4QkFBWSxFQUFDLE1BQU0sRUFBRSxJQUFJLENBQUMsU0FBUyxFQUFFLElBQUksRUFBRSxJQUFJLENBQUMsU0FBUyxFQUFDLENBQUMsQ0FBQztHQUM1RTs7ZUFqQkcsWUFBWTs7V0FtQko7VUFRTixJQUFJLEVBRUYsYUFBYSxFQUlmLGNBQWM7Ozs7Ozs7OzZDQWJQLDJCQUFXOzs7Ozs7OztrQkFDZCxJQUFJLEtBQUssQ0FBQyx1REFBdUQsQ0FBQzs7OztBQUcxRSxnQkFBSSxDQUFDLFdBQVcsQ0FBQyxZQUFZLENBQUMsY0FBYyxDQUFDLENBQUM7OztBQUcxQyxnQkFBSSxHQUFHLENBQUMsSUFBSSxDQUFDLFNBQVMsR0FBRyxTQUFTLENBQUM7O0FBRWpDLHlCQUFhLEdBQUcsU0FBaEIsYUFBYSxDQUFJLE1BQU0sRUFBSztBQUNoQyxxQkFBTyxNQUFNLENBQUMsT0FBTyxDQUFDLHdCQUF3QixDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUM7YUFDeEQ7O0FBRUcsMEJBQWMsR0FBRyxLQUFLOzs7NkNBRWxCLElBQUksQ0FBQyxPQUFPLEVBQUU7Ozs7O0FBR3BCLGdCQUFJLENBQUMsSUFBSSxHQUFHLDBEQUFpQyxJQUFJLEVBQUU7QUFDakQsc0JBQVEsRUFBRSxNQUFNO2FBQ2pCLENBQUMsQ0FBQztBQUNILDBCQUFjLEdBQUcsSUFBSSxDQUFDOzs7bUJBR0gsQ0FBQyxRQUFRLEVBQUUsUUFBUSxDQUFDOzs7QUFBbEMsa0JBQUksTUFBTSxXQUFBLENBQUE7QUFDYixvQkFBSyxJQUFJLENBQUMsRUFBRSxZQUFVLE1BQU0sQ0FBQyxXQUFXLEVBQUUsRUFBSSxVQUFDLEtBQUssRUFBSzs7Ozs7O0FBQ3ZELHFEQUFjLEtBQUssaUhBQUU7d0JBQVosQ0FBQzs7QUFDUix3Q0FBSSxJQUFJLE9BQUssTUFBTSxVQUFLLENBQUMsQ0FBQyxJQUFJLEVBQUUsQ0FBRyxDQUFDO21CQUNyQzs7Ozs7Ozs7Ozs7Ozs7O2VBQ0YsQ0FBQyxDQUFDOzs7QUFMTCxpREFBeUM7O2FBTXhDOzs7QUFHRCxnQkFBSSxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsTUFBTSxFQUFFLFVBQUMsSUFBSSxFQUFFLE1BQU0sRUFBSztBQUNyQyw0QkFBYyxHQUFHLEtBQUssQ0FBQztBQUN2QixrQkFBSSxNQUFLLEtBQUssS0FBSyxZQUFZLENBQUMsYUFBYSxJQUN6QyxNQUFLLEtBQUssS0FBSyxZQUFZLENBQUMsY0FBYyxFQUFFO0FBQzlDLG9CQUFJLEdBQUcsR0FBRyxnREFBOEMsSUFBSSx1QkFDeEMsTUFBTSxDQUFFLENBQUM7QUFDN0Isb0NBQUksS0FBSyxDQUFDLEdBQUcsQ0FBQyxDQUFDO0FBQ2Ysc0JBQUssV0FBVyxDQUFDLFlBQVksQ0FBQyxhQUFhLENBQUMsQ0FBQztlQUM5QzthQUNGLENBQUMsQ0FBQztBQUNILGdDQUFJLElBQUksQ0FBQyxpQ0FBK0IsSUFBSSxDQUFDLFlBQVksZUFDN0MsSUFBSSxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBRSxDQUFDLENBQUM7Ozs7NkNBR3hCLElBQUksQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLGFBQWEsQ0FBQzs7Ozs2Q0FHOUIsSUFBSSxDQUFDLGFBQWEsRUFBRTs7O0FBQzFCLGdCQUFJLENBQUMsV0FBVyxDQUFDLFlBQVksQ0FBQyxZQUFZLENBQUMsQ0FBQzs7Ozs7Ozs7QUFFNUMsZ0JBQUksQ0FBQyxJQUFJLENBQUMsWUFBWSxDQUFDLFdBQVcsaUJBQUksQ0FBQzs7OztpQkFHbkMsY0FBYzs7Ozs7OzZDQUNWLElBQUksQ0FBQyxJQUFJLENBQUMsSUFBSSxFQUFFOzs7QUFFeEIsZ0NBQUksYUFBYSxnQkFBRyxDQUFDOzs7Ozs7O0tBRXhCOzs7V0FFUyxxQkFBRztBQUNYLFVBQUksSUFBSSxDQUFDLEtBQUssS0FBSyxZQUFZLENBQUMsWUFBWSxFQUFFO0FBQzVDLGVBQU8sSUFBSSxDQUFDO09BQ2I7O0FBRUQsYUFBTyxJQUFJLENBQUMsT0FBTyxDQUFDLFNBQVMsQ0FBQztLQUMvQjs7O1dBRW1COzs7O2dEQUdYLElBQUk7Ozs7Ozs7S0FnQlo7Ozs7Ozs7Ozs7Ozs7Ozs7OztXQUVlOzs7Ozs2Q0FDRCxJQUFJLENBQUMsT0FBTyxDQUFDLE9BQU8sQ0FBQyxTQUFTLEVBQUUsS0FBSyxDQUFDOzs7Ozs7Ozs7O0tBQ3BEOzs7V0FFa0Isc0JBQUMsSUFBSTs7OztBQUN0QixnQkFBSSxDQUFDLFdBQVcsR0FBRyxJQUFJLENBQUMsT0FBTyxDQUFDLFdBQVcsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxDQUFDOzs2Q0FDekQsSUFBSSxDQUFDLE9BQU8sQ0FBQyxPQUFPLENBQUMsVUFBVSxFQUFFLE1BQU0sRUFBRSxFQUFDLG1CQUFtQixFQUFFLElBQUksRUFBQyxDQUFDOzs7Ozs7O0tBQzVFOzs7V0FFVTtVQUFDLFVBQVUseURBQUcsSUFBSTs7OztBQUMzQixnQkFBSSxVQUFVLEVBQUU7QUFDZCxrQkFBSSxDQUFDLFdBQVcsQ0FBQyxZQUFZLENBQUMsY0FBYyxDQUFDLENBQUM7YUFDL0M7OztpQkFFSyxJQUFJLENBQUMsSUFBSTs7Ozs7OzZDQUNMLElBQUksQ0FBQyxJQUFJLENBQUMsSUFBSSxFQUFFOzs7QUFFeEIsZ0JBQUksVUFBVSxFQUFFO0FBQ2Qsa0JBQUksQ0FBQyxXQUFXLENBQUMsWUFBWSxDQUFDLGFBQWEsQ0FBQyxDQUFDO2FBQzlDOzs7Ozs7OztBQUVELGdDQUFJLEtBQUssZ0JBQUcsQ0FBQzs7Ozs7OztLQUVoQjs7O1dBRVcscUJBQUMsS0FBSyxFQUFFO0FBQ2xCLFVBQUksQ0FBQyxLQUFLLEdBQUcsS0FBSyxDQUFDO0FBQ25CLDBCQUFJLEtBQUssc0NBQW1DLEtBQUssUUFBSSxDQUFDO0FBQ3RELFVBQUksQ0FBQyxJQUFJLENBQUMsWUFBWSxDQUFDLGFBQWEsRUFBRSxFQUFDLEtBQUssRUFBTCxLQUFLLEVBQUMsQ0FBQyxDQUFDO0tBQ2hEOzs7V0FFaUIscUJBQUMsR0FBRyxFQUFFLE1BQU0sRUFBRSxJQUFJOzs7Ozs2Q0FDckIsSUFBSSxDQUFDLE9BQU8sQ0FBQyxPQUFPLENBQUMsR0FBRyxFQUFFLE1BQU0sRUFBRSxJQUFJLENBQUM7Ozs7Ozs7Ozs7S0FDckQ7OztXQUVjLGtCQUFDLEdBQUcsRUFBRSxHQUFHOzs7Ozs2Q0FDVCxJQUFJLENBQUMsT0FBTyxDQUFDLFdBQVcsQ0FBQyxHQUFHLEVBQUUsR0FBRyxDQUFDOzs7Ozs7Ozs7O0tBQ2hEOzs7V0FFYTtVQUNSLEdBQUc7Ozs7QUFBSCxlQUFHOzs7QUFFUCxlQUFHLEdBQUcsdURBQXVELEdBQ3ZELGtCQUFrQixHQUFHLElBQUksQ0FBQyxTQUFTLEdBQUcsWUFBWSxHQUNsRCw0REFBNEQsR0FDNUQsNkRBQTZELEdBQzdELGNBQWMsQ0FBQztBQUNyQixnQ0FBSSxJQUFJLDhDQUE0QyxHQUFHLENBQUcsQ0FBQzs7OzZDQUduRCxBQUFDLHNCQUFFLFNBQVMsQ0FBQywyQkFBRyxJQUFJLENBQUMsQ0FBRSxHQUFHLENBQUM7OztBQUNqQyxnQ0FBSSxJQUFJLENBQUMsMkNBQTJDLENBQUMsQ0FBQzs7Ozs7Ozs7QUFFdEQsZ0NBQUksSUFBSSxDQUFDLHNDQUFzQyxDQUFDLENBQUM7Ozs7Ozs7S0FFcEQ7OztXQUVtQjs7OztBQUNsQixnQ0FBSSxLQUFLLENBQUMsc0NBQXNDLENBQUMsQ0FBQzs7Ozs7NkNBSTFDLElBQUksQ0FBQyxPQUFPLENBQUMsT0FBTyxDQUFDLEdBQUcsRUFBRSxRQUFRLENBQUM7Ozs7Ozs7Ozs7QUFFekMsZ0NBQUksSUFBSSxDQUFDLGlHQUNZLENBQUMsQ0FBQzs7Ozs7OztLQUUxQjs7O1NBbkxHLFlBQVk7R0FBUyxvQkFBTyxZQUFZOztBQXNMOUMsWUFBWSxDQUFDLFdBQVcsR0FBRyxvQkFBb0IsQ0FBQztBQUNoRCxZQUFZLENBQUMsYUFBYSxHQUFHLGNBQWMsQ0FBQztBQUM1QyxZQUFZLENBQUMsYUFBYSxHQUFHLFNBQVMsQ0FBQztBQUN2QyxZQUFZLENBQUMsY0FBYyxHQUFHLFVBQVUsQ0FBQztBQUN6QyxZQUFZLENBQUMsWUFBWSxHQUFHLFFBQVEsQ0FBQztBQUNyQyxZQUFZLENBQUMsY0FBYyxHQUFHLFVBQVUsQ0FBQzs7cUJBRTFCLFlBQVkiLCJmaWxlIjoibGliXFx3aW5hcHBkcml2ZXIuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgZXZlbnRzIGZyb20gJ2V2ZW50cyc7XHJcbmltcG9ydCB7IEpXUHJveHkgfSBmcm9tICdhcHBpdW0tYmFzZS1kcml2ZXInO1xyXG5pbXBvcnQgbG9nIGZyb20gJy4vbG9nZ2VyJztcclxuaW1wb3J0IHsgU3ViUHJvY2VzcyB9IGZyb20gJ3RlZW5fcHJvY2Vzcyc7XHJcbmltcG9ydCB7IFdBRF9JTlNUQUxMX1BBVEgsIHZlcmlmeVdBRCB9IGZyb20gJy4vaW5zdGFsbGVyJztcclxuLy9pbXBvcnQgeyByZXRyeUludGVydmFsIH0gZnJvbSAnYXN5bmNib3gnO1xyXG5pbXBvcnQgY3AgZnJvbSAnY2hpbGRfcHJvY2Vzcyc7XHJcbmltcG9ydCBCIGZyb20gJ2JsdWViaXJkJztcclxuXHJcbmNvbnN0IFJFUURfUEFSQU1TID0gWydhcHAnXTtcclxuY29uc3QgREVGQVVMVF9IT1NUID0gJzEyNy4wLjAuMSc7XHJcbmNvbnN0IERFRkFVTFRfUE9SVCA9IFwiNDgyM1wiOyAvLyAgc2hvdWxkIGJlIG5vbi00NzIzIHRvIGF2b2lkIGNvbmZsaWN0IG9uIHRoZSBzYW1lIGJveFxyXG5cclxuY2xhc3MgV2luQXBwRHJpdmVyIGV4dGVuZHMgZXZlbnRzLkV2ZW50RW1pdHRlciB7XHJcbiAgY29uc3RydWN0b3IgKG9wdHMgPSB7fSkge1xyXG4gICAgY29uc3Qge2hvc3QsIHBvcnR9ID0gb3B0cztcclxuICAgIHN1cGVyKCk7XHJcblxyXG4gICAgZm9yIChsZXQgcmVxIG9mIFJFUURfUEFSQU1TKSB7XHJcbiAgICAgIGlmICghb3B0cyB8fCAhb3B0c1tyZXFdKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBPcHRpb24gJyR7cmVxfScgaXMgcmVxdWlyZWQhYCk7XHJcbiAgICAgIH1cclxuICAgICAgdGhpc1tyZXFdID0gb3B0c1tyZXFdO1xyXG4gICAgfVxyXG5cclxuICAgIHRoaXMucHJveHlIb3N0ID0gaG9zdCB8fCBERUZBVUxUX0hPU1Q7XHJcbiAgICB0aGlzLnByb3h5UG9ydCA9IHBvcnQgfHwgREVGQVVMVF9QT1JUO1xyXG4gICAgdGhpcy5wcm9jID0gbnVsbDtcclxuICAgIHRoaXMuc3RhdGUgPSBXaW5BcHBEcml2ZXIuU1RBVEVfU1RPUFBFRDtcclxuICAgIHRoaXMuandwcm94eSA9IG5ldyBKV1Byb3h5KHtzZXJ2ZXI6IHRoaXMucHJveHlIb3N0LCBwb3J0OiB0aGlzLnByb3h5UG9ydH0pO1xyXG4gIH1cclxuXHJcbiAgYXN5bmMgc3RhcnQgKCkge1xyXG4gICAgaWYgKCFhd2FpdCB2ZXJpZnlXQUQoKSkge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDb3VsZCBub3QgdmVyaWZ5IFdpbkFwcERyaXZlciBpbnN0YWxsOyByZS1ydW4gaW5zdGFsbFwiKTtcclxuICAgIH1cclxuICAgICAgICBcclxuICAgIHRoaXMuY2hhbmdlU3RhdGUoV2luQXBwRHJpdmVyLlNUQVRFX1NUQVJUSU5HKTtcclxuICAgIFxyXG4gICAgLy8gWFhYWUQgVE9ETzogd291bGQgYmUgYmV0dGVyIGlmIFdpbkFwcERyaXZlciBkaWRuJ3QgcmVxdWlyZSBwYXNzaW5nIGluIC93ZC9odWIgYXMgYSBwYXJhbVxyXG4gICAgbGV0IGFyZ3MgPSBbdGhpcy5wcm94eVBvcnQgKyBcIi93ZC9odWJcIl07XHJcblxyXG4gICAgY29uc3Qgc3RhcnREZXRlY3RvciA9IChzdGRvdXQpID0+IHtcclxuICAgICAgcmV0dXJuIHN0ZG91dC5pbmRleE9mKFwibGlzdGVuaW5nIGZvciByZXF1ZXN0c1wiKSAhPT0gLTE7ICAgICAgICBcclxuICAgIH07XHJcblxyXG4gICAgbGV0IHByb2Nlc3NJc0FsaXZlID0gZmFsc2U7XHJcbiAgICB0cnkge1xyXG4gICAgICBhd2FpdCB0aGlzLmtpbGxBbGwoKTtcclxuXHJcbiAgICAgIC8vIHNldCB1cCBvdXIgc3VicHJvY2VzcyBvYmplY3RcclxuICAgICAgdGhpcy5wcm9jID0gbmV3IFN1YlByb2Nlc3MoV0FEX0lOU1RBTExfUEFUSCwgYXJncywge1xyXG4gICAgICAgIGVuY29kaW5nOiAndWNzMidcclxuICAgICAgfSk7XHJcbiAgICAgIHByb2Nlc3NJc0FsaXZlID0gdHJ1ZTtcclxuXHJcbiAgICAgIC8vIGhhbmRsZSBsb2cgb3V0cHV0XHJcbiAgICAgIGZvciAobGV0IHN0cmVhbSBvZiBbJ1NURE9VVCcsICdTVERFUlInXSkge1xyXG4gICAgICAgIHRoaXMucHJvYy5vbihgbGluZXMtJHtzdHJlYW0udG9Mb3dlckNhc2UoKX1gLCAobGluZXMpID0+IHtcclxuICAgICAgICAgIGZvciAobGV0IGwgb2YgbGluZXMpIHtcclxuICAgICAgICAgICAgbG9nLmluZm8oYFske3N0cmVhbX1dICR7bC50cmltKCl9YCk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIGhhbmRsZSBvdXQtb2YtYm91bmQgZXhpdCBieSBzaW1wbHkgZW1pdHRpbmcgYSBzdG9wcGVkIHN0YXRlXHJcbiAgICAgIHRoaXMucHJvYy5vbignZXhpdCcsIChjb2RlLCBzaWduYWwpID0+IHtcclxuICAgICAgICBwcm9jZXNzSXNBbGl2ZSA9IGZhbHNlO1xyXG4gICAgICAgIGlmICh0aGlzLnN0YXRlICE9PSBXaW5BcHBEcml2ZXIuU1RBVEVfU1RPUFBFRCAmJlxyXG4gICAgICAgICAgICB0aGlzLnN0YXRlICE9PSBXaW5BcHBEcml2ZXIuU1RBVEVfU1RPUFBJTkcpIHtcclxuICAgICAgICAgIGxldCBtc2cgPSBgV2luQXBwRHJpdmVyIGV4aXRlZCB1bmV4cGVjdGVkbHkgd2l0aCBjb2RlICR7Y29kZX0sIGAgK1xyXG4gICAgICAgICAgICAgICAgICAgIGBzaWduYWwgJHtzaWduYWx9YDtcclxuICAgICAgICAgIGxvZy5lcnJvcihtc2cpO1xyXG4gICAgICAgICAgdGhpcy5jaGFuZ2VTdGF0ZShXaW5BcHBEcml2ZXIuU1RBVEVfU1RPUFBFRCk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9KTtcclxuICAgICAgbG9nLmluZm8oYFNwYXduaW5nIHdpbmFwcGRyaXZlciB3aXRoOiAke3RoaXMud2luYXBwZHJpdmVyfSBgICtcclxuICAgICAgICAgICAgICAgYCR7YXJncy5qb2luKCcgJyl9YCk7XHJcblxyXG4gICAgICAvLyBzdGFydCBzdWJwcm9jIGFuZCB3YWl0IGZvciBzdGFydERldGVjdG9yXHJcbiAgICAgIGF3YWl0IHRoaXMucHJvYy5zdGFydChzdGFydERldGVjdG9yKTtcclxuXHJcbiAgICAgIC8vIFhYWFlEIFRPRE86IGJyaW5nIHRoaXMgYmFjayBvbmNlIFdpbkFwcERyaXZlciBzdXBwb3J0cyBzdGF0dXMgY29ycmVjdGx5XHJcbiAgICAgIGF3YWl0IHRoaXMud2FpdEZvck9ubGluZSgpO1xyXG4gICAgICB0aGlzLmNoYW5nZVN0YXRlKFdpbkFwcERyaXZlci5TVEFURV9PTkxJTkUpO1xyXG4gICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICB0aGlzLmVtaXQoV2luQXBwRHJpdmVyLkVWRU5UX0VSUk9SLCBlKTtcclxuICAgICAgLy8ganVzdCBiZWNhdXNlIHdlIGhhZCBhbiBlcnJvciBkb2Vzbid0IG1lYW4gdGhlIHdpbmFwcGRyaXZlciBwcm9jZXNzXHJcbiAgICAgIC8vIGZpbmlzaGVkOyB3ZSBzaG91bGQgY2xlYW4gdXAgaWYgbmVjZXNzYXJ5XHJcbiAgICAgIGlmIChwcm9jZXNzSXNBbGl2ZSkge1xyXG4gICAgICAgIGF3YWl0IHRoaXMucHJvYy5zdG9wKCk7XHJcbiAgICAgIH1cclxuICAgICAgbG9nLmVycm9yQW5kVGhyb3coZSk7XHJcbiAgICB9XHJcbiAgfSAgICAgIFxyXG5cclxuICBzZXNzaW9uSWQgKCkge1xyXG4gICAgaWYgKHRoaXMuc3RhdGUgIT09IFdpbkFwcERyaXZlci5TVEFURV9PTkxJTkUpIHtcclxuICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHRoaXMuandwcm94eS5zZXNzaW9uSWQ7XHJcbiAgfVxyXG5cclxuICBhc3luYyB3YWl0Rm9yT25saW5lICgpIHtcclxuICAgIC8vIFRPRE8gV0FEIGRvZXNuJ3Qgc3VwcG9ydCB0aGUgc3RhdHVzIGNvbW1hbmQgY29ycmVjdGx5LCBzbyBqdXN0IHJldHVyblxyXG4gICAgLy8gdHJ1ZSBmb3Igbm93XHJcbiAgICByZXR1cm4gdHJ1ZTtcclxuXHJcbiAgICAvLyB3ZSBuZWVkIHRvIG1ha2Ugc3VyZSBXQUQgaGFzbid0IGNyYXNoZWRcclxuICAgIC8qXHJcbiAgICBsZXQgd2luYXBwZHJpdmVyU3RvcHBlZCA9IGZhbHNlO1xyXG4gICAgYXdhaXQgcmV0cnlJbnRlcnZhbCgyMCwgMjAwLCBhc3luYyAoKSA9PiB7XHJcbiAgICAgIGlmICh0aGlzLnN0YXRlID09PSBXaW5BcHBEcml2ZXIuU1RBVEVfU1RPUFBFRCkge1xyXG4gICAgICAgIC8vIHdlIGFyZSBlaXRoZXIgc3RvcHBlZCBvciBzdG9wcGluZywgc28gc29tZXRoaW5nIHdlbnQgd3JvbmdcclxuICAgICAgICB3aW5hcHBkcml2ZXJTdG9wcGVkID0gdHJ1ZTtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuICAgICAgYXdhaXQgdGhpcy5nZXRTdGF0dXMoKTtcclxuICAgIH0pO1xyXG4gICAgaWYgKHdpbmFwcGRyaXZlclN0b3BwZWQpIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdXaW5BcHBEcml2ZXIgY3Jhc2hlZCBkdXJpbmcgc3RhcnR1cC4nKTtcclxuICAgIH0qL1xyXG4gIH1cclxuXHJcbiAgYXN5bmMgZ2V0U3RhdHVzICgpIHtcclxuICAgIHJldHVybiBhd2FpdCB0aGlzLmp3cHJveHkuY29tbWFuZCgnL3N0YXR1cycsICdHRVQnKTtcclxuICB9XHJcblxyXG4gIGFzeW5jIHN0YXJ0U2Vzc2lvbiAoY2Fwcykge1xyXG4gICAgdGhpcy5wcm94eVJlcVJlcyA9IHRoaXMuandwcm94eS5wcm94eVJlcVJlcy5iaW5kKHRoaXMuandwcm94eSk7XHJcbiAgICBhd2FpdCB0aGlzLmp3cHJveHkuY29tbWFuZCgnL3Nlc3Npb24nLCAnUE9TVCcsIHtkZXNpcmVkQ2FwYWJpbGl0aWVzOiBjYXBzfSk7XHJcbiAgfVxyXG5cclxuICBhc3luYyBzdG9wIChlbWl0U3RhdGVzID0gdHJ1ZSkge1xyXG4gICAgaWYgKGVtaXRTdGF0ZXMpIHtcclxuICAgICAgdGhpcy5jaGFuZ2VTdGF0ZShXaW5BcHBEcml2ZXIuU1RBVEVfU1RPUFBJTkcpO1xyXG4gICAgfVxyXG4gICAgdHJ5IHtcclxuICAgICAgaWYgKHRoaXMucHJvYykge1xyXG4gICAgICAgIGF3YWl0IHRoaXMucHJvYy5zdG9wKCk7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKGVtaXRTdGF0ZXMpIHtcclxuICAgICAgICB0aGlzLmNoYW5nZVN0YXRlKFdpbkFwcERyaXZlci5TVEFURV9TVE9QUEVEKTtcclxuICAgICAgfVxyXG4gICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICBsb2cuZXJyb3IoZSk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBjaGFuZ2VTdGF0ZSAoc3RhdGUpIHtcclxuICAgIHRoaXMuc3RhdGUgPSBzdGF0ZTtcclxuICAgIGxvZy5kZWJ1ZyhgV2luQXBwRHJpdmVyIGNoYW5nZWQgc3RhdGUgdG8gJyR7c3RhdGV9J2ApO1xyXG4gICAgdGhpcy5lbWl0KFdpbkFwcERyaXZlci5FVkVOVF9DSEFOR0VELCB7c3RhdGV9KTtcclxuICB9XHJcblxyXG4gIGFzeW5jIHNlbmRDb21tYW5kICh1cmwsIG1ldGhvZCwgYm9keSkge1xyXG4gICAgcmV0dXJuIGF3YWl0IHRoaXMuandwcm94eS5jb21tYW5kKHVybCwgbWV0aG9kLCBib2R5KTtcclxuICB9XHJcblxyXG4gIGFzeW5jIHByb3h5UmVxIChyZXEsIHJlcykge1xyXG4gICAgcmV0dXJuIGF3YWl0IHRoaXMuandwcm94eS5wcm94eVJlcVJlcyhyZXEsIHJlcyk7XHJcbiAgfVxyXG5cclxuICBhc3luYyBraWxsQWxsICgpIHtcclxuICAgIGxldCBjbWQ7XHJcbiAgICAvLyBqcyBoaW50IGNhbm5vdCBoYW5kbGUgYmFja3RpY2tzLCBldmVuIGVzY2FwZWQsIHdpdGhpbiB0ZW1wbGF0ZSBsaXRlcmFsc1xyXG4gICAgY21kID0gXCJGT1IgL0YgXFxcInVzZWJhY2txIHRva2Vucz01XFxcIiAlYSBpbiAoYG5ldHN0YXQgLW5hbyBefCBcIiArXHJcbiAgICAgICAgICBcImZpbmRzdHIgL1IgL0M6XFxcIlwiICsgdGhpcy5wcm94eVBvcnQgKyBcIiBcXFwiYCkgZG8gKFwiICtcclxuICAgICAgICAgIFwiRk9SIC9GIFxcXCJ1c2ViYWNrcVxcXCIgJWIgaW4gKGBUQVNLTElTVCAvRkkgXFxcIlBJRCBlcSAlYVxcXCIgXnwgXCIgK1xyXG4gICAgICAgICAgXCJmaW5kc3RyIC9JIHdpbmFwcGRyaXZlci5leGVgKSBkbyAoSUYgTk9UICViPT1cXFwiXFxcIiBUQVNLS0lMTCBcIiArXHJcbiAgICAgICAgICBcIi9GIC9QSUQgJWEpKVwiO1xyXG4gICAgbG9nLmluZm8oYEtpbGxpbmcgYW55IG9sZCBXaW5BcHBEcml2ZXJzLCBydW5uaW5nOiAke2NtZH1gKTtcclxuICAgIHRyeSB7XHJcbiAgICAgIC8vIHVzZSBjcC5leGVjIGluc3RlYWQgb2YgdGVlbiBwcm9jZXNzIGJlY2F1c2Ugb2YgY3Jhenkgd2luZG93cyBxdW90aW5nXHJcbiAgICAgIGF3YWl0IChCLnByb21pc2lmeShjcC5leGVjKSkoY21kKTtcclxuICAgICAgbG9nLmluZm8oXCJTdWNjZXNzZnVsbHkgY2xlYW5lZCB1cCBvbGQgV2luQXBwRHJpdmVyc1wiKTtcclxuICAgIH0gY2F0Y2ggKGVycikge1xyXG4gICAgICBsb2cuaW5mbyhcIk5vIG9sZCBXaW5BcHBEcml2ZXJzIHNlZW1lZCB0byBleGlzdFwiKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGFzeW5jIGRlbGV0ZVNlc3Npb24gKCkge1xyXG4gICAgbG9nLmRlYnVnKCdEZWxldGluZyBXaW5BcHBEcml2ZXIgc2VydmVyIHNlc3Npb24nKTtcclxuICAgIC8vIHJlbHkgb24gandwcm94eSdzIGludGVsbGlnZW5jZSB0byBrbm93IHdoYXQgd2UncmUgdGFsa2luZyBhYm91dCBhbmRcclxuICAgIC8vIGRlbGV0ZSB0aGUgY3VycmVudCBzZXNzaW9uXHJcbiAgICB0cnkge1xyXG4gICAgICBhd2FpdCB0aGlzLmp3cHJveHkuY29tbWFuZCgnLycsICdERUxFVEUnKTtcclxuICAgIH0gY2F0Y2ggKGVycikge1xyXG4gICAgICBsb2cud2FybihgRGlkIG5vdCBnZXQgY29uZmlybWF0aW9uIFdpbkFwcERyaXZlciBkZWxldGVTZXNzaW9uIHdvcmtlZDsgYCArXHJcbiAgICAgICAgYEVycm9yIHdhczogJHtlcnJ9YCk7XHJcbiAgICB9XHJcbiAgfVxyXG59XHJcblxyXG5XaW5BcHBEcml2ZXIuRVZFTlRfRVJST1IgPSAnd2luYXBwZHJpdmVyX2Vycm9yJztcclxuV2luQXBwRHJpdmVyLkVWRU5UX0NIQU5HRUQgPSAnc3RhdGVDaGFuZ2VkJztcclxuV2luQXBwRHJpdmVyLlNUQVRFX1NUT1BQRUQgPSAnc3RvcHBlZCc7XHJcbldpbkFwcERyaXZlci5TVEFURV9TVEFSVElORyA9ICdzdGFydGluZyc7XHJcbldpbkFwcERyaXZlci5TVEFURV9PTkxJTkUgPSAnb25saW5lJztcclxuV2luQXBwRHJpdmVyLlNUQVRFX1NUT1BQSU5HID0gJ3N0b3BwaW5nJztcclxuXHJcbmV4cG9ydCBkZWZhdWx0IFdpbkFwcERyaXZlcjtcclxuIl19